{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the FRC Programming Guide","text":"<p>This guide does not include how to program in java</p> <p>It also does not cover installation of the WPILib toolkit</p>"},{"location":"notes/","title":"Notes","text":"<p>This is a section full of tiny notes about different things that come up with frc programming </p>"},{"location":"notes/#vs-code-errors","title":"VS Code Errors","text":"<p>Often you may get an error where vs code says libraries or classes are missing when the code compiles just fine. To fix this delete the .gradle and build folders and then close and reopen WPILib vscode. This should refresh the gradle cache meaning that when the java language server restarts it will be able to recognize the new classes or libraries.</p>"},{"location":"Advanced-FRC-Programming/1/","title":"Suppliers, Comsumers, and Optionals","text":""},{"location":"Advanced-FRC-Programming/2/","title":"Swerve with CTRE Swerve Drive","text":""},{"location":"Advanced-FRC-Programming/3/","title":"Pathplanning with Pathplanner","text":""},{"location":"Advanced-FRC-Programming/4/","title":"Vision with PhotonVision","text":""},{"location":"Advanced-FRC-Programming/5/","title":"AdvantageKit and Replay Systems","text":""},{"location":"Advanced-FRC-Programming/6/","title":"Physics Simulation with MapleSim","text":""},{"location":"Advanced-FRC-Programming/7/","title":"Unit Testing and Mocks","text":""},{"location":"Basic-FRC-Programming/1/","title":"First Steps with WPILib","text":""},{"location":"Basic-FRC-Programming/1/#creating-your-first-project","title":"Creating your first project","text":"<p>Its time to create your first ever FRC codebase! To start type Ctrl+Shift+P on windows or Cmd+Shift+P on MacOS. This opens the command pallette which will be a super useful tool going forward. Once its open type in <code>WPILib create</code> and press Enter. This will open the project creation screen.</p> The Command Palette <p>Now at the top of the project creation screen click the select project type button. Choose Template -&gt; java -&gt; Command Robot Skeleton (Advanced). Then select the base folder where it will put the new robot project folder in. Add a project name and team number. Finally check the enable desktop support button and generate the project.</p> Your project creation page should look roughly similar to this"},{"location":"Basic-FRC-Programming/1/#building-and-deploying","title":"Building and Deploying","text":"<p>To build and deploy our code to a robot relies on the command pallette. Open the command pallette and type <code>WPILib deploy</code> and press Enter to deploy. Do the same but with <code>WPILib build</code> if you just want to build the code and not deploy.</p> <p>When you run deploy wpilib will check to see if a robot is connected via the radio. If not, it will error. Both build and deploy will open a terminal at the bottom of your screen allowing you to see if any errors occur during the build process. These could be formatting errors, gradle errors, or just simple compilation errors.</p>"},{"location":"Basic-FRC-Programming/2/","title":"Command Based Programming Theory","text":"<p>Command-based programming is a design pattern used in FRC to structure code in a modular, maintainable, and reusable way. At its core, it involves defining commands\u2014single, reusable units of work\u2014that interact with subsystems\u2014the robot's mechanical and electrical components. This separation of concerns simplifies complex robotic control.</p>"},{"location":"Basic-FRC-Programming/2/#the-command-lifecycle","title":"The Command Lifecycle","text":"<p>A Command represents a single, autonomous task that the robot can perform. Every command follows a well-defined lifecycle managed by the Command Scheduler.</p> <p></p>"},{"location":"Basic-FRC-Programming/2/#1-initialize","title":"1. initialize()","text":"<ul> <li>Called once when the command is first scheduled.  </li> <li>Used to set up the command's initial state, such as resetting encoders, setting initial motor speeds, or preparing internal variables.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#2-execute","title":"2. execute()","text":"<ul> <li>Called repeatedly (typically every robot cycle, e.g., every 20ms) while the command is running.  </li> <li>Contains the main logic of the command, such as driving motors, adjusting pneumatics, or performing calculations. This method should return quickly.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#3-isfinished","title":"3. isFinished()","text":"<ul> <li>Called repeatedly to determine if the command has completed its task.  </li> <li>Returns a boolean value. When it returns true, the command signals the scheduler that it is finished and should be stopped. Examples include checking if a setpoint has been reached, a timer has expired, or a button has been released.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#4-endboolean-interrupted","title":"4. end(boolean interrupted)","text":"<ul> <li>Called once when the command stops, either because isFinished() returned true (finished) or because it was cancelled/interrupted by another command (interrupted).</li> <li>Used to clean up, such as setting motors to zero, disabling actuators, or stopping any active sensors. The interrupted boolean can be used to perform different cleanup based on how the command ended.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#the-command-scheduler","title":"The Command Scheduler","text":"<p>The Command Scheduler is the heart of the command-based system. It acts as a central manager responsible for tracking, running, and terminating all active commands.</p> <p></p>"},{"location":"Basic-FRC-Programming/2/#responsibilities","title":"Responsibilities","text":"<ul> <li>Scheduling: When a command is triggered (e.g., by a button press or another command), the scheduler places it on a list of active commands.  </li> <li>Execution: In the main robot loop, the scheduler iterates through all active commands and calls their respective execute() and isFinished() methods.  </li> <li>Resource Management: It enforces subsystem requirements. If a new command requires a subsystem already in use by an active command, the scheduler will automatically interrupt and stop the currently running command before starting the new one. This prevents conflicting control instructions.  </li> <li>Termination: When a command's isFinished() returns true or it's interrupted, the scheduler calls its end() method and removes it from the active list.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#default-commands","title":"Default Commands","text":"<p>A Default Command is a special type of command associated with a Subsystem.</p> <p></p>"},{"location":"Basic-FRC-Programming/2/#behavior","title":"Behavior","text":"<ul> <li>Always Running (Unless Interrupted): A default command is automatically scheduled by the scheduler to run whenever no other command is currently running and actively requiring its associated subsystem.  </li> <li>Low Priority: It is the lowest priority command for a subsystem and will be automatically interrupted and stopped as soon as any other command requiring that subsystem is scheduled.  </li> <li>Restoration: Once the higher-priority command finishes or is interrupted, the scheduler will automatically restart the default command.</li> </ul>"},{"location":"Basic-FRC-Programming/2/#common-uses","title":"Common Uses","text":"<ul> <li>Idling Behavior: Maintaining a safe or known state, such as holding a mechanism in a specific position using a PID loop.  </li> <li>Manual Control: Assigning continuous joystick or controller input to a subsystem (e.g., joystick control for a drive train).</li> </ul>"},{"location":"Basic-FRC-Programming/3/","title":"Basic Subsystems and Commands","text":"<p>Subsystems are how we organize our code in an frc codebase. They store motors and sensors, hold command factories, and much more! Typically each major mechanism will be seperated into a seperate class for ease of use. Subsystems also handle interrupts. When two commands try to use a subsystem at the same time, which ever command uses it last will get prority and the other command will get interrupted.</p>"},{"location":"Basic-FRC-Programming/3/#parts-of-a-subsystem","title":"Parts of a Subsystem","text":""},{"location":"Basic-FRC-Programming/3/#1-motors-and-sensors","title":"1. Motors and Sensors","text":"<ul> <li>Subsystems are responsible for storing motors and sensors used on the robot</li> <li>Subsystem methods dictate how the the program interacts with a mechanisms electronics</li> </ul>"},{"location":"Basic-FRC-Programming/3/#2-perodic","title":"2. perodic()","text":"<ul> <li>Called repeatedly (typically every robot cycle, e.g., every 20ms) by the Command Scheduler</li> <li>Often used for logging telemetry data about what is going on in the subsystem</li> <li>Also used for mechanisms that need to hold their position by constantly sending control requests</li> </ul>"},{"location":"Basic-FRC-Programming/3/#2-command-factories","title":"2. Command Factories","text":"<ul> <li>Generate commands for the rest of the robot code to use</li> <li>Built using the runOnce, run, etc. subsystem factories that come from inheriting SubsystemBase</li> </ul>"},{"location":"Basic-FRC-Programming/3/#coding-our-first-subsystem","title":"Coding our First Subsystem","text":"<p>Its finally time to get coding! In this section were going to create a simple roller subsystem like what we saw on the 2025 kitbot. It will extend SubsystemBase, hold a simple pwm motor controller, and have command factories for spinning and stopping the roller.</p> The 2025 Kitbot featuring a roller subsystem <p>First create a new folder called <code>Subsystems</code>. In that folder create a file called <code>RollerSubsystem.java</code>. Then put the following code in the file: <pre><code>package frc.robot.Subsystems;\n\nimport edu.wpi.first.wpilibj.motorcontrol.Talon;\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\n\npublic class RollerSubsystem extends SubsystemBase {\n    private Talon motorController;\n\n    public RollerSubsystem() {\n        motorController = new Talon(1);\n    }\n\n    public Command startRollersCommand() {\n        return runOnce(() -&gt; motorController.set(1.0));\n    }\n\n    public Command stopRollersCommand() {\n        return runOnce(() -&gt; motorController.set(0.0));\n    }\n}\n</code></pre> Lets walk through this code line by line to see what we can learn.</p> <p>First we see that this class inherits from the <code>SubsystemBase</code> class and creates a constructor for our class. The <code>SubsystemBase</code> class provides many of the subsystem specific command factories (<code>runOnce()</code>) and other useful tools to make out programming experience easier.</p> <p>Then we see this block of code: <pre><code>private Talon motorController;\n\npublic RollerSubsystem() {\n    motorController = new Talon(1);\n}\n</code></pre> This creates a Talon motor controller on PWM channel 1. The Talon motor controller is rarely used in FRC today but it works based off a PWM signal suppied by the roborio. Channel 1 means our motor is plugged into the 1st channel of the roborio pinout. The Talon motor controller acts as our interface with the actual hardware allowing us to control the speed easily through code.</p> <p>Then we see the next two functions of the class: <pre><code>public Command startRollersCommand() {\n    return runOnce(() -&gt; motorController.set(1.0));\n}\n\npublic Command stopRollersCommand() {\n    return runOnce(() -&gt; motorController.set(0.0));\n}\n</code></pre> These two functions are command generators. The first one, <code>startRollersCommand()</code> generates a Command that sets the motor controller speed to 1.0. This is done through the runOnce function supplied by the SubsystemBase class. </p> <p>By using runOnce we can pass in a function, or lambda in this case, and it will automatically asign create a command that runs that function on initalize. It will also include our subsystem as a mechanism requirement allowing the command to make and recieve interrupts from the command scheduler. </p> <p>We do the same with the <code>stopRollersCommand()</code> except we set the speed to 0.0.</p> <p>Note</p> <p>The lambda function in java <code>() -&gt;</code> will be super useful in almost all aspects of robot code. They are used to supply positions, as bodies for commands, or are even passed as consumers for values. Get comfortable using lambdas!</p> <p>Now we have sucessfully coded our first subsystem! Next lesson will focus on how we trigger those command with user input.</p>"},{"location":"Basic-FRC-Programming/4/","title":"Triggers and User Input","text":"<p>Now that we have our first subsystem we need to be able to trigger commands to occur. This is where triggers come in. First lets go to our <code>RobotContainer.java</code> file in the main codebase folder.</p> <p>At the top of the class lets create an instance of our <code>RollerSubsystem</code> <pre><code>public RollerSubsystem rollerSubsystem;\n\npublic RobotContainer() {\n    rollerSubsystem = new RollerSubsystem();\n\n    configureBindings();\n}\n</code></pre></p> <p>Now that we created our roller subsystem in the robot container, we need to create a controller that can trigger the commands it holds. Lets create that under our roller Subsystem:</p> <pre><code>public RollerSubsystem rollerSubsystem;\npublic CommandXboxController controller;\n\npublic RobotContainer() {\n    rollerSubsystem = new RollerSubsystem();\n    controller = new CommandXboxController(0);\n\n    configureBindings();\n}\n</code></pre> <p>Note</p> <p>We create a <code>CommandXboxController</code> instead of a <code>XboxController</code> as only the command based one supports triggering commands. We create it with port 0 meaning that this xbox controller will connect to whatever is connected to the first controller slot in the driverstation.</p>"},{"location":"Basic-FRC-Programming/5/","title":"The Fundamentals of Controls","text":""},{"location":"Basic-FRC-Programming/6/","title":"The TalonFX Motor Controller","text":""},{"location":"Basic-FRC-Programming/7/","title":"Advanced Commands and Command Groups","text":""},{"location":"Basic-FRC-Programming/8/","title":"Basic Logging and Visualization","text":""}]}